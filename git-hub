#!/usr/bin/env python
# vim: set fileencoding=utf-8 :

# Git command line interface to GitHub.
#
# Written by Leandro Lucarella <leandro.lucarella@sociomantic.com>
#
# Copyright (c) 2013 by Sociomantic Labs GmbH
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.


"""\
Git command line interface to GitHub.

Written by Leandro Lucarella <leandro.lucarella@sociomantic.com>.
"""

VERSION = "git-hub devel"

import re
import sys
import json
import string
import base64
import urllib
import urllib2
import getpass
import os.path
import argparse
import subprocess

DEBUG = 3
INFO  = 2
WARN  = 1
ERR   = 0

def debugf(fmt='', *args, **kwargs):
	if verbose < DEBUG:
		return
	sys.stdout.write(fmt.format(*args, **kwargs) + '\n')

def infof(fmt='', *args, **kwargs):
	if verbose < INFO:
		return
	sys.stdout.write(fmt.format(*args, **kwargs) + '\n')

def warnf(fmt='', *args, **kwargs):
	if verbose < WARN:
		return
	if sys.stderr.isatty():
		sys.stderr.write('\033[33m')
	sys.stderr.write('Warning: ')
	sys.stderr.write(fmt.format(*args, **kwargs))
	if sys.stderr.isatty():
		sys.stderr.write('\033[0m')
	sys.stderr.write('\n')
	sys.stderr.flush()

def errf(fmt='', *args, **kwargs):
	if verbose < ERR:
		return
	if sys.stderr.isatty():
		sys.stderr.write('\033[31m')
	sys.stderr.write('Error: ')
	sys.stderr.write(fmt.format(*args, **kwargs))
	if sys.stderr.isatty():
		sys.stderr.write('\033[0m')
	sys.stderr.write('\n')
	sys.stderr.flush()

def die(fmt='', *args, **kwargs):
	errf(fmt, *args, **kwargs)
	sys.exit(1)

def ask(question, default=None, options=["yes", "no"]):
	if not sys.stdin.isatty():
		return None

	if default not in options and default is not None:
		raise ValueError("invalid default answer: '%s'" % default)

	valid_answers = dict()
	opts_strings = list()
	for opt in options:
		if opt is None:
			raise ValueError("options can't be None")
		valid_answers[opt.lower()] = opt
		valid_answers[opt[0].lower()] = opt
		opt_str = opt.capitalize()
		if default == opt:
			# default in bold
			opt_str = '\033[1m' + opt.upper() + '\033[21m'
		opts_strings.append(opt_str)

	# options in dark
	question += ' \033[2m[' + '/'.join(opts_strings) + '] '

	while True:
		# question in yellow
		sys.stderr.write('\033[33m' + question + '\033[0m')
		choice = raw_input().lower().strip()
		if default is not None and choice == '':
			return default
		elif choice in valid_answers:
			return valid_answers[choice]
		else:
			errf("Invalid answer, valid options: {}",
				', '.join(options))


GIT_CONFIG_PREFIX = 'hub.'

class GitError (subprocess.CalledProcessError):

	def __init__(self, returncode, cmd, output):
		super(GitError, self).__init__(returncode, cmd, output)

	def __str__(self):
		return '%s failed (return code: %s)\n%s' % (' '.join(self.cmd),
				self.returncode, self.output)
def args_to_list(args):
	if len(args) == 1:
		return args[0].split()
	return list(args)

def git(*args, **kwargs):
	args = args_to_list(args)
	args.insert(0, 'git')
	kwargs['stdout'] = subprocess.PIPE
	kwargs['stderr'] = subprocess.PIPE
	proc = subprocess.Popen(args, **kwargs)
	(stdout, stderr) = proc.communicate()
	if proc.returncode != 0 or stderr:
		raise GitError(proc.returncode, args, stderr.rstrip('\n'))
	return stdout.rstrip('\n')

# Same as git() but inserts --quiet at quiet_index if verbose is less than DEBUG
def git_quiet(quiet_index, *args, **kwargs):
	args = args_to_list(args)
	if verbose < DEBUG:
		args.insert(quiet_index, '--quiet')
	return git(*args, **kwargs)

def git_push(*args, **kwargs):
	cmd = ['push']
	if 'force' in kwargs:
		cmd.append('--force')
		del kwargs['force']
	cmd += args_to_list(args)
	git_quiet(1, *cmd, **kwargs)

class NO_DEFAULT:
	pass

def git_config(name, default=None, prefix=GIT_CONFIG_PREFIX, value=None, opts=()):
	name = prefix + name
	cmd = ['config'] + list(opts) + [name]
	try:
		if value is not None:
			cmd.append(value)
		return git(*cmd)
	except subprocess.CalledProcessError as e:
		if e.returncode == 1:
			if default is not NO_DEFAULT:
				return default
			die("Can't find '{}' config key in git config. "
					"Read the man page for details.",
					name)
		raise e


def editor(help_msg, msg=None):
	prog = git('var', 'GIT_EDITOR')
	dotgit = git('rev-parse', '--git-dir')
	fname = os.path.join(dotgit, 'HUB_EDITMSG')
	with file(fname, 'w') as f:
		f.write(msg or '')
		f.write(help_msg)
	status = subprocess.call([prog, fname])
	if status != 0:
		die("Editor returned {}, aborting...", status)
	with file(fname) as f:
		msg = f.read()
	return msg


class Config:

	def __init__(self):
		self.username = git_config('username', getpass.getuser())
		self.oauthtoken = git_config('oauthtoken')
		self.upstream = git_config('upstream')
		if self.upstream and '/' not in self.upstream:
			die("Invalid hub.upstream configuration, '/' not found")
		self.forkrepo = git_config('forkrepo')
		if not self.forkrepo and self.upstream:
			upstream = self.upstream.split('/')
			self.forkrepo = self.username + '/' + upstream[1]
		self.forkremote = git_config('forkremote', 'origin')
		self.pullbase = git_config('pullbase', 'master')
		self.urltype = git_config('urltype', 'ssh_url')

	def check(self, name):
		if getattr(self, name) is None:
			die("Can't find '{}{}' config key in git config. "
					"Read the man page for details.",
					GIT_CONFIG_PREFIX, name)


# Manages GitHub request handling authentication and content headers.
#
# The real interesting methods are created after the class declaration, for
# each type of request: head(), get(), post(), patch(), put() and delete().
#
# All these methods take an URL (relative to the base_url) and optionally an
# arbitrarily number of positional or keyword arguments (but not both at the
# same type). The extra arguments, if present, are serialized as json and sent
# as the request body.
# All these methods return None if the response is empty, or the deserialized
# json data received in the body of the response.
#
# Example:
#
#    r = req.post('/repos/sociomantic/test/labels/', name=name, color=color)
#
# See http://developer.github.com/ for more details on the GitHub API
class RequestManager:

	base_url = 'https://api.github.com'
	basic_auth = None

	def set_basic_auth(self, username, password):
		self.basic_auth = "Basic " + base64.urlsafe_b64encode("%s:%s" %
			(username, password))

	def auth_urlopen(self, url, method, body):
		req = urllib2.Request(self.base_url + url, body)
		if self.basic_auth:
			req.add_header("Authorization", self.basic_auth)
		elif config.oauthtoken:
			req.add_header("Authorization", "bearer " +
					config.oauthtoken)
		req.add_header("Content-Type", "application/json")
		req.add_header("Accept", "application/json")
		req.add_header("Content-Length", str(len(body) if body else 0))
		req.get_method = lambda: method
		debugf('{}', req.get_full_url())
		debugf('{}', req.header_items())
		debugf('{}', req.get_data())
		return urllib2.urlopen(req)

	def dump(self, *args, **kwargs):
		if args and kwargs:
			raise ValueError('args and kwargs are mutually '
				'exclusive')
		if args:
			return json.dumps(args)
		if kwargs:
			return json.dumps(kwargs)
		return None

	def json_req(self, url, method, *args, **kwargs):
		if method.lower() in ('post', 'patch', 'put'):
			body = self.dump(*args, **kwargs)
		else:
			body = None
			url += '?' + urllib.urlencode(kwargs)
		debugf("Request: {} {}\n{}", method, url, body)
		res = self.auth_urlopen(url, method, body)
		data = res.read()
		debugf("Response:\n{}", data)
		if data:
			return json.loads(data)
		return None

# Create RequestManager.head(), get(), ... methods
# We need the make_method() function to make Python bind the method variable
# (from the loop) early (in the loop) instead of when is called. Otherwise all
# methods get bind with the last value of method ('delete') in this case, which
# is not only what we want, is also very dangerous.
def make_method(method):
	return lambda self, url, *args, **kwargs: \
		self.json_req(url, method.upper(), *args, **kwargs)
for method in ('head', 'get', 'post', 'patch', 'put', 'delete'):
	setattr(RequestManager, method, make_method(method))


def check_empty_message(msg):
	if not msg.strip():
		die("Message is empty, aborting...")
	return msg

message_markdown_help = '''\
# Remember GitHub will parse comments and descriptions as GitHub
# Flavored Markdown.
# For details see: http://github.github.com/github-flavored-markdown/
#
# Lines starting with '# ' (note the space after the hash!) will be
# ignored, and an empty message aborts the command. The space after the
# hash is required by comments to avoid accidentally commenting out a
# line starting with a reference to an issue (#4 for example). If you
# want to include Markdown headers in your message, use the Setext-style
# headers, which consist on underlining titles with '=' for first-level
# or '-' for second-level headers.
'''
def clean_message(msg):
	lines = msg.splitlines()
	# Remove comment lines
	lines = [l for l in lines if not l.strip().startswith('#')]
	return '\n'.join(lines)

def split_titled_message(msg):
	lines = check_empty_message(clean_message(msg)).splitlines()
	title = lines[0]
	body = ''
	if len(lines) > 1:
		if lines[1].strip():
			die("Wrong message format, leave an "
				"empty line between the title "
				"and the body")
		body = '\n'.join(lines[2:])
	return (title, body)


class CmdGroup (object):

	subcommand_suffix = 'Cmd'

	@classmethod
	def setup_parser(cls, parser):
		suffix = cls.subcommand_suffix
		subcommands = [getattr(cls, a) for a in dir(cls)
				if a.endswith(suffix)]
		if not subcommands:
			return
		title = None
		if hasattr(cls, 'cmd_title'):
			title = cls.cmd_title
		subparsers = parser.add_subparsers(title=title)
		for cmd in subcommands:
			name = cmd.__name__.lower()[:-len(suffix)]
			if hasattr(cmd, 'cmd_name'):
				name = cmd.cmd_name
			help = cmd.__doc__
			if hasattr(cmd, 'cmd_help'):
				help = cmd.cmd_help
			p = subparsers.add_parser(name, help=help)
			cmd.setup_parser(p)
			if not hasattr(cmd, 'run'):
				continue
			if hasattr(cmd, 'cmd_required_config'):
				def make_closure(cmd):
					def check_config_and_run(parser, args):
						for c in cmd.cmd_required_config:
							config.check(c)
						cmd.run(parser, args)
					return check_config_and_run
				p.set_defaults(run=make_closure(cmd))
			else:
				p.set_defaults(run=cmd.run)


class SetupCmd (object):

	cmd_help = 'perform an initial setup to connect to GitHub'

	@classmethod
	def setup_parser(cls, parser):
		parser.add_argument('-u', '--username',
			help="GitHub's username (login name)")
		parser.add_argument('-p', '--password',
			help="GitHub's password (will not be stored)")
		group = parser.add_mutually_exclusive_group()
		group.add_argument('--global',
			dest='opts', action='store_const', const=['--global'],
			help="store settings in the global configuration "
			"(see git config --global for details)")
		group.add_argument('--system',
			dest='opts', action='store_const', const=['--system'],
			help="store settings in the system configuration "
			"(see git config --system for details)")
		parser.set_defaults(opts=[])
	@classmethod
	def setup(cls, username=None, password=None, opts=()):
		if (username is None or password is None) and \
				not sys.stdin.isatty():
			die("Can't perform an interactive setup outside a tty")
		if username is None:
			username = getpass.getuser()
			reply = raw_input('GitHub username [%s]: ' % username)
			if reply:
				username = reply
		if password is None:
			password = getpass.getpass(
				'GitHub password (will not be stored): ')
		req.set_basic_auth(username, password)
		note = 'git-hub'
		if config.forkrepo:
			proj = config.forkrepo.split('/', 1)[1]
			note += ' (%s)' % proj
		auth = req.post('/authorizations', note=note,
				scopes=['user', 'repo'])
		git_config('username', value=username, opts=opts)
		git_config('oauthtoken', value=auth['token'], opts=opts)
	@classmethod
	def run(cls, parser, args):
		cls.setup(args.username, args.password, args.opts)


class CloneCmd (object):

	cmd_help = 'clone a GitHub repository (and fork as needed)'

	@classmethod
	def setup_parser(cls, parser):
		parser.add_argument('repository', metavar='REPO',
			help="name of the repository to fork; in "
			"<owner>/<project> format is the upstream repository, "
			"if only <project> is specified, the <owner> part is "
			"taken from hub.username")
		parser.add_argument('dest', metavar='DEST', nargs='?',
			help="destination directory where to put the new "
			"cloned repository")
		parser.add_argument('-r', '--remote', metavar='NAME',
			help="use NAME as the upstream remote repository name "
			"instead of the default 'upstream'")
	@classmethod
	def run(cls, parser, args):
		upstream = args.repository
		remote = args.remote or 'upstream'
		if '/' in upstream:
			(owner, proj) = upstream.split('/', 1)
			for repo in req.get('/user/repos'):
				if repo['name'] == proj and repo['fork']:
					break
			else: # Fork not found
				infof('Forking {} ...', upstream)
				repo = req.post('/repos/' + upstream + '/forks')
				infof('\tforked to {}', repo['full_name'])
			repo = req.get('/repos/' + repo['full_name'])
		else: # no '/' in upstream
			repo = req.get('/repos/%s/%s' % (config.username,
					upstream))
			if not repo['fork']:
				warnf('Repository {} is not a fork, just '
					'clonning, upstream will not be set',
					repo['full_name'])
				upstream = None
			else:
				upstream = repo['parent']['full_name']
		dest = args.dest or repo['name']
		infof('Cloning {} to {}', repo[config.urltype], dest)
		git_quiet(1, 'clone', repo[config.urltype], dest)
		if upstream:
			os.chdir(dest)
			git_config('upstream', value=upstream)
			git('remote', 'add', '-f', remote,
					repo['parent'][config.urltype])


class IssueUtil (object):

	cmd_required_config = ['upstream', 'oauthtoken']
	name = 'pull request'
	gh_path = 'issues'
	id_var = 'ISSUE'
	help_msg = '''
# Please enter the title and description below.
#
# The first line is interpreted as the title. An optional description
# can follow after and empty line.
#
# Example:
#
#   Some title
#
#   Some description that can span several
#   lines.
#
''' + message_markdown_help
	comment_help_msg = '''
# Please enter your comment below.
#
''' + message_markdown_help

	@classmethod
	def print_issue(cls, issue):
		infof('[{number}] {title} ({user[login]})\n{}{html_url}',
				' ' * (len(str(issue['number'])) + 3),
				**issue)
		debugf('{}', json.dumps(issue, indent=4, sort_keys=True))

	@classmethod
	def print_comment(cls, comment):
		body = comment['body']
		infof('[{id}] {}{} ({user[login]})', body[:60],
				'â€¦' if len(body) > 60 else '',
				' ' * (len(str(comment['id'])) + 3),
				**comment)
		debugf('{}', json.dumps(comment, indent=4, sort_keys=True))

	@classmethod
	def url(cls, number=None):
		s = '/repos/%s/%s' % (config.upstream, cls.gh_path)
		if number:
			s += '/' + number
		return s

	@classmethod
	def editor(cls, msg=None):
		return editor(cls.help_msg, msg)

	@classmethod
	def comment_editor(cls, msg=None):
		return editor(cls.comment_help_msg, msg)

	@classmethod
	def clean_and_post_comment(cls, issue_num, body):
		# URL fixed to issues, pull requests comments are made through
		# issues
		url = '/repos/%s/issues/%s/comments' % (config.upstream,
				issue_num)
		body = check_empty_message(clean_message(body))
		comment = req.post(url, body=body)
		cls.print_comment(comment)

class IssueCmd (CmdGroup):

	cmd_title = 'subcommands to manage issues'
	cmd_help = 'manage issues'

	class ListCmd (IssueUtil):
		cmd_help = "show a list of open %ss" % IssueUtil.name
		@classmethod
		def setup_parser(cls, parser):
			parser.add_argument('-c', '--closed',
				action='store_true', default=False,
				help="show only closed pull requests")
			parser.add_argument('-C', '--created-by-me',
				action='store_true',
				help=("show only %ss created by me" %
						IssueUtil.name))
			parser.add_argument('-A', '--assigned-to-me',
				action='store_true',
				help=("show only %ss assigned to me" %
						IssueUtil.name))
		@classmethod
		def run(cls, parser, args):
			def filter(issue, name):
				a = issue[name]
				if a and a['login'] == config.username:
					return True
			state = 'closed' if args.closed else 'open'
			issues = req.get(cls.url(), state=state)
			if args.created_by_me and args.assigned_to_me:
				issues = [i for i in issues
					if filter(i, 'assignee') or
							filter(i, 'user')]
			elif args.created_by_me:
				issues = [i for i in issues
						if filter(i, 'user')]
			elif args.assigned_to_me:
				issues = [i for i in issues
					if filter(i, 'assignee')]
			for issue in issues:
				cls.print_issue(issue)

	class ShowCmd (IssueUtil):
		cmd_help = "show details for existing %ss" % IssueUtil.name
		@classmethod
		def setup_parser(cls, parser):
			parser.add_argument('issues',
				nargs='+', metavar=cls.id_var,
				help="number identifying the issue to show")
		@classmethod
		def run(cls, parser, args):
			for number in args.issues:
				issue = req.get(cls.url(number))
				cls.print_issue(issue)

	class NewCmd (IssueUtil):
		cmd_help = "create a new %s" % IssueUtil.name
		@classmethod
		def setup_parser(cls, parser):
			parser.add_argument('-m', '--message', metavar='MSG',
				help="issue's title (and description); the "
				"first line is used as the issue title and "
				"any text after an empty line is used as "
				"the optional body")
			parser.add_argument('-l', '--label',
				metavar='LABEL', action='append',
				help="attach LABEL to the issue (can be "
				"specified multiple times to set multiple "
				"labels)")
			parser.add_argument('-a', '--assign', metavar='USER',
				help="assign an user to the issue; must be a "
				"valid GitHub login name")
			parser.add_argument('-M', '--milestone', metavar='ID',
				help="assign the milestone identified by the "
				"number ID to the issue")
		@classmethod
		def run(cls, parser, args):
			msg = args.message or cls.editor()
			(title, body) = split_titled_message(msg)
			issue = req.post(cls.url(), title=title, body=body,
				assignee=args.assignee, labels=args.labels,
				milestone=args.milestone)
			cls.print_issue(issue)

	class UpdateCmd (IssueUtil):
		cmd_help = "update an existing %s" % IssueUtil.name
		@classmethod
		def setup_parser(cls, parser):
			parser.add_argument('issue', metavar=cls.id_var,
				help="number identifying the issue to update")
			parser.add_argument('-m', '--message', metavar='MSG',
				help="new issue title (and description); the "
				"first line is used as the issue title and "
				"any text after " "an empty line is used as "
				"the optional body")
			parser.add_argument('-e', '--edit-message',
				action='store_true', default=False,
				help="open the default $GIT_EDITOR to edit the "
				"current title (and description) of the issue")
			parser.add_argument('-o', '--open',
				action='store_true', default=False,
				help="reopen the issue")
			parser.add_argument('-c', '--close',
				action='store_true', default=False,
				help="close the issue")
			parser.add_argument('-l', '--label',
				metavar='LABEL', action='append',
				help="if one or more labels are specified, "
				"they will replace the current issue labels; "
				"otherwise the labels are unchanged. If one of "
				"the labels is empty, the labels will be "
				"cleared (so you can use -l'' to clear the "
				"labels of an issue)")
			parser.add_argument('-a', '--assign', metavar='USER',
				help="assign an user to the issue; must be a "
				"valid GitHub login name")
			parser.add_argument('-M', '--milestone', metavar='ID',
				help="assign the milestone identified by the "
				"number ID to the issue")
		@classmethod
		def run(cls, parser, args):
			# URL fixed to issues, pull requests updates are made
			# through issues to allow changing labels, assignee and
			# milestone (even when GitHub itself doesn't support it
			# :D)
			url = '/repos/%s/issues/%s' % (config.upstream,
					args.issue)
			params = dict()
			# Should labels be cleared?
			if (args.labels and len(args.labels) == 1 and
					not args.labels[0]):
				params['labels'] = []
			elif args.labels:
				params['labels'] = args.labels
			if args.open:
				params['state'] = 'open'
			if args.close:
				params['state'] = 'closed'
			if args.assign is not None:
				params['assignee'] = args.assign
			if args.milestone is not None:
				params['milestone'] = args.milestone
			msg = args.message
			if args.edit_message:
				if not msg:
					issue = req.get(url)
					msg = issue['title']
					if issue['body']:
						msg += '\n\n' + issue['body']
				msg = cls.editor(msg)
				(title, body) = split_titled_message(msg)
				params['title'] = title
				params['body'] = body
			issue = req.patch(url, **params)
			cls.print_issue(issue)

	class CommentCmd (IssueUtil):
		cmd_help = "add a comment to an existing %s" % IssueUtil.name
		@classmethod
		def setup_parser(cls, parser):
			parser.add_argument('issue', metavar=cls.id_var,
				help="number identifying the issue to close")
			parser.add_argument('-m', '--message', metavar='MSG',
				help="comment to be added to the issue; if "
				"this option is not used, the default "
				"$GIT_EDITOR is opened to write the comment")
		@classmethod
		def run(cls, parser, args):
			body = args.message or cls.comment_editor()
			cls.clean_and_post_comment(args.issue, body)

	class CloseCmd (IssueUtil):
		cmd_help = "close an opened %s" % IssueUtil.name
		@classmethod
		def setup_parser(cls, parser):
			parser.add_argument('issue', metavar=cls.id_var,
				help="number identifying the issue to close")
			parser.add_argument('-m', '--message', metavar='MSG',
				help="add a comment to the issue before "
				"closing it")
			parser.add_argument('-e', '--edit-message',
				action='store_true', default=False,
				help="open the default $GIT_EDITOR to write "
				"a comment to be added to the issue before "
				"closing it")
		@classmethod
		def run(cls, parser, args):
			msg = args.message
			if args.edit_message:
				msg = cls.comment_editor(msg)
			if msg:
				cls.clean_and_post_comment(args.issue, msg)
			issue = req.patch(cls.url(args.issue), state='closed')
			cls.print_issue(issue)


class PullUtil (IssueUtil):

	name = 'pull request'
	gh_path = 'pulls'
	id_var = 'PULL'
	rebase_msg = 'This pull request has been rebased via ' \
			'`git hub pull rebase`. Original pull request HEAD ' \
			'was {}, new (rebased) HEAD is {}'

	@classmethod
	def head_ref(cls):
		ref = git('rev-parse --abbrev-ref HEAD')
		if ref == 'HEAD':
			ref = git('rev-list -1 HEAD')
		return ref

	@classmethod
	def push(cls, head, remote_head, force):
		local_hash = git('rev-parse', head)
		remote_hash = 'x' # dummy variable that doesn't match any git hash
		remote_branch = '%s/%s' % (config.forkremote, head)
		status = subprocess.call('git rev-parse --verify --quiet ' +
				remote_branch + ' > /dev/null', shell=True)
		if status == 0: # remote reference found, get the hash
			remote_hash = git('rev-parse', remote_branch)
		if local_hash != remote_hash:
			infof('Pushing {} to {} in {}', head, remote_head,
					config.forkremote)
			git_push(config.forkremote, head+':'+remote_head,
					force=force)

	@classmethod
	def get_default_branch_msg(cls, branch_name):
		msg = git_config('branch.%s.description' % branch_name, '', '')
		if msg:
			return msg
		return git('log -1 --pretty=format:%s%n%n%b ' + branch_name)

class PullCmd (IssueCmd):

	cmd_title = 'subcommands to manage pull requests'
	cmd_help = 'manage pull requests'

	class ListCmd (PullUtil, IssueCmd.ListCmd):
		pass

	class ShowCmd (PullUtil, IssueCmd.ShowCmd):
		pass

	class UpdateCmd (PullUtil, IssueCmd.UpdateCmd):
		pass

	class CommentCmd (PullUtil, IssueCmd.CommentCmd):
		pass

	class CloseCmd (PullUtil, IssueCmd.CloseCmd):
		pass

	class NewCmd (PullUtil):
		cmd_help = "create a new %s" % PullUtil.name
		@classmethod
		def setup_parser(cls, parser):
			parser.add_argument('head', metavar='HEAD', nargs='?',
				help="branch (or git ref) where your changes "
				"are implemented")
			parser.add_argument('-m', '--message', metavar='MSG',
				help="pull request title (and description); "
				"the first line is used as the pull request "
				"title and any text after an empty line is "
				"used as the optional body")
			parser.add_argument('-b', '--base', metavar='BASE',
				help="branch (or git ref) you want your "
				"changes pulled into (uses hub.pullbase or "
				"'master' in hub.upstream by default)")
			parser.add_argument('-c', '--create-branch',
				metavar='NAME',
				help="create a new remote branch with NAME "
				"as the real head for the pull request instead "
				"of using the HEAD name passed as 'head'")
			parser.add_argument('-f', '--force',
				action='store_true', default=False,
				help="force some Git operations (for example "
				"'push')")
		@classmethod
		def run(cls, parser, args):
			head = args.head or cls.head_ref()
			remote_head = args.create_branch or head
			base = args.base or config.pullbase
			msg = args.message
			gh_head = config.username + ':' + remote_head
			if not msg:
				msg = cls.editor(cls.get_default_branch_msg(head))
			(title, body) = split_titled_message(msg)
			cls.push(head, remote_head, force=args.force)
			pull = req.post(cls.url(), head=gh_head, base=base,
					title=title, body=body)
			cls.print_issue(pull)

	class AttachCmd (PullUtil):
		cmd_help = "attach code to an existing issue"
		@classmethod
		def setup_parser(cls, parser):
			parser.add_argument('issue', metavar='ISSUE',
				help="issue ID to attach code to")
			parser.add_argument('head', metavar='HEAD', nargs='?',
				help="branch (or git ref) where your changes "
				"are implemented")
			parser.add_argument('-m', '--message', metavar='MSG',
				help="add a comment to the issue/new pull "
				"request")
			parser.add_argument('-e', '--edit-message',
				action='store_true', default=False,
				help="open the default $GIT_EDITOR to write "
				"a comment to be added to the issue after "
				"attaching the code to it")
			parser.add_argument('-b', '--base', metavar='BASE',
				help="branch (or git ref) you want your "
				"changes pulled into (uses hub.pullbase or "
				"'master' in hub.upstream by default)")
			parser.add_argument('-c', '--create-branch',
				metavar='NAME',
				help="create a new remote branch with NAME "
				"as the real head for the pull request instead "
				"of using the HEAD name passed as 'head'")
			parser.add_argument('-f', '--force',
				action='store_true', default=False,
				help="force some Git operations (for example "
				"'push')")
		@classmethod
		def run(cls, parser, args):
			head = args.head or cls.head_ref()
			remote_head = args.create_branch or head
			base = args.base or config.pullbase
			msg = args.message
			if args.edit_message:
				if not msg:
					msg = cls.get_default_branch_msg(head)
				msg = cls.comment_editor(msg)
			gh_head = config.username + ':' + remote_head
			cls.push(head, remote_head, force=args.force)
			pull = req.post(cls.url(), issue=args.issue, base=base,
					head=gh_head)
			cls.print_issue(pull)
			if msg:
				cls.clean_and_post_comment(args.issue, msg)

# This class is top-level just for convenience, because is too big. Is added to
# PullCmd after is completely defined!
class RebaseCmd (PullUtil):
	cmd_help = "close a pull request by rebasing its base branch"

	stash_msg_base = "stashed by git hub pull rebase"

	in_conflict = False

	saved_old_ref = None
	saved_message = None
	saved_edit_msg = None

	@classmethod
	def setup_parser(cls, parser):
		group = parser.add_mutually_exclusive_group(required=True)
		group.add_argument('pull',
			metavar=cls.id_var, nargs='?',
			help="number identifying the pull request to rebase")
		group.add_argument('--continue', dest='action',
			action='store_const', const='--continue',
			help="continue an ongoing rebase")
		group.add_argument('--abort', dest='action',
			action='store_const', const='--abort',
			help="abort an ongoing rebase")
		group.add_argument('--skip', dest='action',
			action='store_const', const='--skip',
			help="skip current patch and continue")
		parser.add_argument('-m', '--message', metavar='MSG',
			help="add a comment to the pull request before closing "
			"it; if not specified a default comment is added (to "
			"avoid adding a comment at all use -m'')")
		parser.add_argument('-e', '--edit-message',
			action='store_true', default=False,
			help="open the default $GIT_EDITOR to edit the comment "
			"to be added to the pull request before closing it")
		parser.add_argument('-f', '--force',
			action='store_true', default=False,
			help="force some Git operations (for example 'push')")

	@classmethod
	def run(cls, parser, args):
		ongoing_rebase_pull_id = cls.read_rebasing_file()
		if args.pull is not None and ongoing_rebase_pull_id is not None:
			die("Another pull rebase is in progress, can't start "
				"a new one")
		if (args.pull is None and ongoing_rebase_pull_id is None and
					args.action != '--abort'):
			die("Can't {}, no pull rebase is in progress",
				args.action)

		if args.pull is not None:
			if cls.rebasing():
				die("Can't start a pull rebase while a "
					"regular reabase is in progress")
			cls.start_rebase(args)
		else:
			args.pull = ongoing_rebase_pull_id
			if args.message is None:
				args.message = cls.saved_message
			if not args.edit_message:
				args.edit_message = cls.saved_edit_msg

			if args.action == '--abort':
				cls.abort_rebase(args)
			else:
				cls.check_continue_rebasing(args)
				cls.start_rebase(args)

	@classmethod
	def check_continue_rebasing(cls, args):
		if cls.rebasing():
			return
		answer = ask("No rebase in progress found for this pull "
			"rebase, do you want to continue as if the rebase was "
			"successfully finished, abort the rebasing cancelling "
			"the whole rebase or just quit?", default="quit",
			options=['continue', 'abort', 'quit'])
		if answer is None:
			die("No rebase in progress found for this "
				"pull rebase, don't know how to proceed")
		elif answer == 'abort':
			cls.abort_rebase(args)
		elif answer == 'continue':
			pull = cls.get_pull(args.pull, False)
			push_sha = git('rev-parse HEAD')
			cls.update_github(args, pull, push_sha)
			cls.remove_rebasing_file()
		sys.exit(0)

	@classmethod
	def abort_rebase(cls, args):
		aborted = cls.force_rebase_abort()
		if args.pull is not None and cls.saved_old_ref is not None:
			cls.clean_ongoing_rebase(args.pull, cls.saved_old_ref,
					warnf)
			aborted = True
		aborted = cls.remove_rebasing_file() or aborted
		aborted = cls.pop_stashed() or aborted
		if not aborted:
			die("Nothing done, maybe there isn't an ongoing rebase "
				"of a pull request?")

	@classmethod
	def start_rebase(cls, args):
		starting = args.action is None
		pull = cls.get_pull(args.pull, starting)
		if starting:
			git_quiet(2, 'stash save --all %s' % cls.stash_msg(pull))
		try:
			pushed_sha = cls.fetch_rebase_push(args, pull)
		finally:
			if not cls.in_conflict:
				cls.pop_stashed()
		try:
			pull = cls.update_github(args, pull, pushed_sha)
		except:
			errf("GitHub information couldn't be updated "
				"correctly, but the pull request was "
				"successfully rebased. Check GitHub "
				"for details...")
		finally:
			cls.print_issue(pull)

	@classmethod
	def get_pull(cls, pull_id, check_all):
		pull = req.get(cls.url(pull_id))
		if pull['merged']:
			infof("Nothing to do, already merged (--abort to get "
					"back to normal)")
			sys.exit(0)
		if check_all and pull['state'] == 'closed':
			answer = ask("The pull request is closed, are you sure "
				"you want to rebase it?", default="no")
			if answer is None:
				die("Can't rebase/merge, pull request is closed")
			elif answer == 'no':
				sys.exit(0)
		if check_all and not pull['mergeable']:
			answer = ask("The pull request is not in a mergeable "
				"state, do you want to continue anyway?",
				default="no")
			if answer is None:
				die("Can't continue, the pull request isn't "
					"in a mergeable state")
			elif answer == 'no':
				sys.exit(0)
		return pull

	@classmethod
	def get_tmp_ref(cls, pull_id):
		return 'git-hub-pull-rebase-%s' % pull_id

	@classmethod
	def pop_stashed(cls):
		stashed_state = cls.get_stashed_state()
		if stashed_state:
			git_quiet(2, 'stash', 'pop')
			return True
		elif stashed_state is False:
			warf("Stash produced by this command found "
				"(stash@{{}}) but not as the last stashed "
				"changes, leaving the stashed as it is", i)
		return False

	@classmethod
	def get_stashed_state(cls):
		stash_msg_re = re.compile(cls.stash_msg_base + r' \d+$')
		stashs = git('stash', 'list').splitlines()
		for i, stash in enumerate(stashs):
			if stash_msg_re.match(stash):
				if i == 0:
					return True
				else:
					return False
		return None

	@classmethod
	def stash_msg(cls, pull):
		return '"%s %s"' % (cls.stash_msg_base, pull['number'])

	@classmethod
	def fetch_rebase_push(cls, args, pull):
		starting = args.action is None
		head_url = pull['head']['repo'][config.urltype]
		head_ref = pull['head']['ref']
		base_url = pull['base']['repo'][config.urltype]
		base_ref = pull['base']['ref']
		tmp_ref = cls.get_tmp_ref(pull['number'])
		old_ref = cls.saved_old_ref
		if old_ref is None:
			old_ref = cls.head_ref()

		if starting:
			infof('Fetching {} from {}', head_ref, head_url)
			git_quiet(1, 'fetch', head_url, head_ref)
			git_quiet(1, 'checkout', '-b', tmp_ref,
				'FETCH_HEAD')
		try:
			if starting:
				infof('Rebasing to {} in {}',
						base_ref, base_url)
				git_quiet(1, 'fetch', base_url, base_ref)
				cls.create_rebasing_file(pull, args, old_ref)
			cls.rebase(args, pull)
			infof('Pushing results to {} in {}',
					base_ref, base_url)
			git_push(base_url, 'HEAD:' + base_ref, force=args.force)
			return git('rev-parse HEAD')
		finally:
			if not cls.in_conflict:
				cls.clean_ongoing_rebase(pull['number'], old_ref)

	@classmethod
	def clean_ongoing_rebase(cls, pull_id, old_ref, errfunc=die):
		tmp_ref = cls.get_tmp_ref(pull_id)
		git_quiet(1, 'reset', '--hard')
		try:
			git_quiet(1, 'checkout', old_ref)
		except subprocess.CalledProcessError as e:
			errfunc("Can't checkout '{}', maybe it was removed "
				"during the rebase? {}",  old_ref, e)
		try:
			git_quiet(1, 'branch', '-D', tmp_ref)
		except subprocess.CalledProcessError as e:
			errfunc("Can't remove temporary branch '{}', maybe it was "
				"removed during the rebase? {}",  tmp_ref, e)

	@classmethod
	def rebase(cls, args, pull):
		starting = args.action is None
		try:
			if starting:
				git_quiet(1, 'rebase', 'FETCH_HEAD')
			else:
				git('rebase', args.action)
		except subprocess.CalledProcessError as e:
			if e.returncode == 1 and cls.rebasing():
				cls.in_conflict = True
				die("Conflict detected, resolve "
					"conflicts and run git hub "
					"pull rebase --continue to "
					"proceed")
			raise e
		finally:
			if not cls.in_conflict:
				# Always try to abort the rebasing, in case
				# there was an error
				cls.remove_rebasing_file()
				cls.force_rebase_abort()

	@classmethod
	def force_rebase_abort(cls):
		try:
			git('rebase', '--abort', stderr=subprocess.STDOUT)
		except subprocess.CalledProcessError:
			return False
		return True

	@classmethod
	def update_github(cls, args, pull, pushed_sha):
		pull_sha = pull['head']['sha']
		msg = args.message
		if msg is None and pull_sha != pushed_sha:
			msg = cls.rebase_msg.format(pull_sha, pushed_sha)
		if args.edit_message:
			msg = cls.comment_editor(msg)
		if msg:
			cls.clean_and_post_comment(args.pull, msg)
		pull = req.get(cls.url(args.pull))
		if pull['state'] == 'open' and pull_sha != pushed_sha:
			pull = req.patch(cls.url(args.pull),
					state='closed')
		return pull

	@classmethod
	def rebasing(cls):
		dotgit = git('rev-parse', '--git-dir')
		return os.path.exists(dotgit+'/rebase-apply/rebasing')

	@classmethod
	def rebasing_file_name(cls):
		dotgit = git('rev-parse', '--git-dir')
		return os.path.join(dotgit, 'HUB_PULL_REBASING')

	@classmethod
	def read_rebasing_file(cls):
		fname = cls.rebasing_file_name()
		if os.path.exists(fname):
			try:
				with file(fname) as f:
					# id read as string
					pull_id = f.readline()[:-1] # strip \n
					cls.saved_old_ref = f.readline()[:-1]
					assert cls.saved_old_ref
					edit_msg = f.readline()[:-1]
					cls.saved_edit_msg = edit_msg is "True"
					msg = f.read()
					if msg == '\n':
						msg = ''
					elif not msg:
						msg = None
					cls.saved_message = msg
					return pull_id
			except EnvironmentError as e:
				die("Error reading pull rebase information "
					"file '{}': {}", fname, e)
		return None

	@classmethod
	def create_rebasing_file(cls, pull, args, old_ref):
		fname = cls.rebasing_file_name()
		try:
			fd = os.open(cls.rebasing_file_name(),
					os.O_WRONLY | os.O_CREAT | os.O_EXCL,
					0o777)
			with os.fdopen(fd, 'w') as f:
				# id written as string
				f.write(str(pull['number']) + '\n')
				f.write(old_ref + '\n')
				f.write(repr(args.edit_message) + '\n')
				if (args.message is not None):
					f.write(args.message + '\n')
		except EnvironmentError as e:
			die("Error writing pull rebase information "
				"file '{}': {}", fname, e)

	@classmethod
	def remove_rebasing_file(cls):
		fname = cls.rebasing_file_name()
		if not os.path.exists(fname):
			return False
		try:
			os.unlink(fname)
		except EnvironmentError as e:
			die("Error removing pull rebase information "
				"file '{}': {}", fname, e)
		return True

PullCmd.RebaseCmd = RebaseCmd


class HubCmd (CmdGroup):
	cmd_title = "subcommands"
	cmd_help = "git command line interface to GitHub"
	SetupCmd = SetupCmd
	CloneCmd = CloneCmd
	IssueCmd = IssueCmd
	PullCmd = PullCmd


def main():
	global args, config, req, verbose

	parser = argparse.ArgumentParser(
			description='Git command line interface to GitHub')
	parser.add_argument('--version', action='version', version=VERSION)
	parser.add_argument('-v', '--verbose', action='count', default=INFO,
		help="be more verbose (can be specified multiple times to get "
		"extra verbosity)")
	parser.add_argument('-s', '--silent', action='count', default=0,
		help="be less verbose (can be specified multiple times to get "
		"less verbosity)")
	HubCmd.setup_parser(parser)
	args = parser.parse_args()
	verbose = args.verbose - args.silent

	config = Config()

	req = RequestManager()

	# Temporary warning to note the configuration variable changes
	if git_config('password') is not None:
		warnf('It looks like your {0}password configuration '
			'variable is set.\nThis variable is not used '
			'anymore, you might want to delete it.\nFor example: '
			'git config --global --unset {0}password',
			GIT_CONFIG_PREFIX)

	args.run(parser, args)


if __name__ == '__main__':
	try:
		main()
	except urllib2.HTTPError as error:
		try:
			err = json.loads(error.read())
			prefix = 'GitHub error: '
			if 'message' in err:
				errf('{}{message}', prefix, **err)
			if 'errors' in err:
				for e in err['errors']:
					if 'message' in err:
						errf('{}{message}',
							' ' * len(prefix), **e)
			debugf('{}', error)
			debugf('{}', error.geturl())
			debugf('{}', error.headers)
			debugf('{}', error.read())
		except:
			errf('{}', error)
			errf('{}', error.geturl())
			errf('{}', error.headers)
			errf('{}', error.read())
			sys.exit(3)
		sys.exit(4)
	except urllib2.URLError as error:
		errf('Network error: {}', error)
		sys.exit(5)
	except KeyboardInterrupt:
		sys.exit(6)
	except GitError as error:
		errf('{} failed (return code: {})',
			' '.join(error.cmd), error.returncode)
		if verbose >= ERR:
			sys.stderr.write(error.output + '\n')
		sys.exit(7)


